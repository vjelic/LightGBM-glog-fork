{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-4a7e1207-bc4b-499a-901e-e986f3c7e0ec",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the outcome of the program, leading to a variety of security issues such as password cracking, session hijacking, and others.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use strong cryptographic random number generators. In C++, the `<random>` library provides a variety of random number generators that can be used. Among these, `std::random_device` is a universally generating random number engine if available, otherwise it has an implementation-defined behavior.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to use `std::random_device` to generate a random number:\n\n```cpp\n#include <random>\n\nint main() {\n    std::random_device rd;  // Will be used to obtain a seed for the random number engine\n    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n    std::uniform_int_distribution<> distrib(1, 6);\n\n    int random_number = distrib(gen);\n    // Use the random number...\n}\n```\n\nIn this code, `std::random_device` is used to seed a Mersenne Twister random number generator (`std::mt19937`). Then, a uniform distribution is created to generate a random number between 1 and 6.\n\n## Library Dependencies\n\nThe above code requires the `<random>` library.\n\n## References\n"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-98590d52-34a4-4c6e-8814-eefa2c26357e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the size of the destination buffer is less than the size of the source buffer, a buffer overflow can occur. This can lead to unexpected behavior, including program crashes, data corruption, and potentially the execution of malicious code.\n\nIn the provided code snippet, the vulnerability arises from the calculation `(meta_->num_bin - meta_->offset)`. If this calculation results in a value larger than the size of `data_int16_`, a buffer overflow will occur.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using functions that limit the amount of data copied to the size of the destination buffer. For example, `strncpy` and `snprintf` in C, or `std::copy` and `std::copy_n` in C++.\n\n## Source Code Fix Recommendation\n\nA potential fix for the provided code snippet could be:\n\n```cpp\nsize_t copy_size = (meta_->num_bin - meta_->offset);\nif (copy_size <= sizeof(data_int16_)) {\n    memcpy(data_int16_, memory_data, copy_size);\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional libraries are needed for this code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always refer to the latest OWASP and CWE documentation for the most accurate and up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-9465daa9-7191-4cea-a532-8a325c71617a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `sizeof(data_size_t)` is larger than the size of `query_boundaries_.data()`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code, potentially gaining unauthorized access or control over the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif(sizeof(data_size_t) <= query_boundaries_.data().size()) {\n    memcpy(query_boundaries_.data(), mem_ptr, sizeof(data_size_t));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we check if `sizeof(data_size_t)` is less than or equal to the size of `query_boundaries_.data()` before calling `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-12ebfb2a-393d-49e1-aab5-df4cd3fa4278",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if the size of `label_t` is larger than the size of `label_.data()`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code snippet:\n\n```cpp\nsize_t size = sizeof(label_t);\nif (size <= label_.size()) {\n    memcpy(label_.data(), mem_ptr, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fixed version, we first check if the size of `label_t` is less than or equal to the size of `label_.data()`. If it is, we proceed with the `memcpy`. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a9b922c7-ded7-42bf-a90a-d88fbc903a6f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the size of the destination buffer is less than the size of the source buffer, it can lead to a buffer overflow. This can cause a program to crash, or in some cases, allow an attacker to execute arbitrary code.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `memory_data` to `data_`. The size of the data to be copied is determined by `(meta_->num_bin - meta_->offset)`. If this value is larger than the size of `data_`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using functions that limit the amount of data copied to the size of the destination buffer. For example, `strncpy` or `memcpy_s` in C++, which take the size of the destination buffer as an argument and ensure that no more than this amount of data is copied.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\nsize_t copy_size = meta_->num_bin - meta_->offset;\nif (copy_size <= sizeof(data_)) {\n    memcpy(data_, memory_data, copy_size);\n} else {\n    // Handle error: copy_size is larger than buffer\n}\n```\n\nIn this fixed code, we first calculate the size of the data to be copied and then check if it is larger than the size of the destination buffer. If it is, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet does not indicate any specific library dependencies. However, the `memcpy` function is part of the C standard library, so the code will need to include the `<cstring>` header file.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8d2cc877-9738-420f-a4d6-eef9fd740ee8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the size of the destination buffer is less than the size of the source buffer, it can lead to a buffer overflow. This can cause a program to crash, or in some cases, allow an attacker to execute arbitrary code.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `memory_data` to `data_`. The size of the data to be copied is determined by `(meta_->num_bin - meta_->offset)`. If this value is larger than the size of `data_`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using functions that limit the amount of data copied to the size of the destination buffer. For example, `strncpy` or `memcpy_s` in C++, which take the size of the destination buffer as an argument and ensure that no more than this amount of data is copied.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\nsize_t copy_size = meta_->num_bin - meta_->offset;\nif (copy_size <= sizeof(data_)) {\n    memcpy(data_, memory_data, copy_size);\n} else {\n    // Handle error: copy_size is larger than buffer\n}\n```\n\nIn this fixed code, we first calculate the size of the data to be copied and then check if it is larger than the size of the destination buffer. If it is, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet does not indicate any specific library dependencies. However, the `memcpy` function is part of the C standard library, so the code will need to include the `<cstring>` header file.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e13665b0-c3df-4c48-aac6-63da2f56c41b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is greater than the size of the destination buffer. In the provided code snippet, if the size of `label_t` is greater than the size of `weights_.data()`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(label_t);\nif (weights_.size() >= size) {\n    memcpy(weights_.data(), mem_ptr, size);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\nIn this fixed code, we first calculate the size of the data being copied. Then, we check if the destination buffer (`weights_.data()`) is large enough to hold this data. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<cstddef>`: This library provides the `size_t` type.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-033740f4-f46c-46d9-b5d3-3e1b2b182d33",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer alternative that includes size checks. For example:\n\n```cpp\n#include <algorithm>\n\nstd::copy(labels, labels + sizeof(label_t), label_.begin() + start_index);\n```\n\nThis code uses the `std::copy` function from the `<algorithm>` library, which is safer than `memcpy` because it checks the size of the destination before copying.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` for `memcpy`\n- `<algorithm>` for `std::copy`\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-44a5865f-2aa9-47c5-bfb6-2c68c05e4aef",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to vulnerabilities if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can cause crashes, data corruption, and other unexpected behavior. This is a common vulnerability in C and C++ programming.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`. \n\nAdditionally, consider using safer functions that include protections against buffer overflow, such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure not to write past it.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `memcpy_s`:\n\n```cpp\nsize_t dest_size = sizeof(init_score_.data()) - dest_offset;\nsize_t src_size = sizeof(init_scores) - source_offset;\nsize_t copy_size = sizeof(double);\n\nif (dest_size >= copy_size && src_size >= copy_size) {\n    memcpy_s(init_score_.data() + dest_offset, dest_size, init_scores + source_offset, copy_size);\n} else {\n    // Handle error: buffer not large enough\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-33a0181a-d858-40f7-8f1f-3efdd13627cd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `num_bin_ * sizeof(int)` is larger than the size of `bin_2_categorical_.data()`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t bufferSize = num_bin_ * sizeof(int);\nif (bufferSize <= bin_2_categorical_.size()) {\n    memcpy(bin_2_categorical_.data(), buffer, bufferSize);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first calculate the size of the data being copied and then check if it is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are valid and active at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-88c82f39-d74f-421d-9f1f-e375bbacb1dd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the vulnerability arises if the size of `buffer` is larger than `most_freq_bin_`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be achieved by checking the size of the source data before copying it to the destination buffer. \n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = sizeof(most_freq_bin_);\nif (sizeof(buffer) <= size) {\n    memcpy(&most_freq_bin_, buffer, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the size of `buffer` is less than or equal to the size of `most_freq_bin_`. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `<cstring>` header file in your C++ code.\n\n```cpp\n#include <cstring>\n```\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-97a3636f-4543-4eff-a48b-f749e0552cc6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as data corruption, system crashes, and unauthorized access to system memory.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include built-in checks for buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(data_size_t) <= (queries_.size() - start_index)) {\n    memcpy(queries_.data() + start_index, queries, sizeof(data_size_t));\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first check if the destination buffer (`queries_.data() + start_index`) is large enough to hold the data being copied (`sizeof(data_size_t)`). If it is, we proceed with the `memcpy`. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet does not explicitly indicate any library dependencies. However, the `memcpy` function is part of the C Standard Library (`<cstring>` in C++), and the `data` method is part of the Standard Template Library (STL), specifically the `vector` class (`<vector>` in C++).\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-4a7e1207-bc4b-499a-901e-e986f3c7e0ec",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid Using Weak or Non-Cryptographic Random Number Generators"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/treelearner/feature_histogram.hpp"
                },
                "region": {
                  "startLine": 1724,
                  "startColumn": 35,
                  "endLine": 1724,
                  "endColumn": 42,
                  "charOffset": 75365,
                  "charLength": 7,
                  "snippet": {
                    "text": "Random(",
                    "rendered": {
                      "text": "Random(",
                      "markdown": "`Random(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-98590d52-34a4-4c6e-8814-eefa2c26357e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/treelearner/feature_histogram.hpp"
                },
                "region": {
                  "startLine": 971,
                  "startColumn": 9,
                  "endLine": 972,
                  "endColumn": 48,
                  "charOffset": 41527,
                  "charLength": 81,
                  "snippet": {
                    "text": "memcpy(data_int16_, memory_data,\n                (meta_->num_bin - meta_->offset)",
                    "rendered": {
                      "text": "memcpy(data_int16_, memory_data,\n                (meta_->num_bin - meta_->offset)",
                      "markdown": "`memcpy(data_int16_, memory_data,\n                (meta_->num_bin - meta_->offset)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/treelearner/feature_histogram.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41527,
                        "charLength": 81
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data_int16_, <size of data_int16_>,  memory_data, \n                (meta_->num_bin - meta_->offset)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9465daa9-7191-4cea-a532-8a325c71617a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/io/metadata.cpp"
                },
                "region": {
                  "startLine": 767,
                  "startColumn": 9,
                  "endLine": 767,
                  "endColumn": 70,
                  "charOffset": 27486,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy(query_boundaries_.data(), mem_ptr, sizeof(data_size_t)",
                    "rendered": {
                      "text": "memcpy(query_boundaries_.data(), mem_ptr, sizeof(data_size_t)",
                      "markdown": "`memcpy(query_boundaries_.data(), mem_ptr, sizeof(data_size_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/io/metadata.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27486,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s(query_boundaries_.data(), <size of query_boundaries_.data()>,  mem_ptr,  sizeof(data_size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-12ebfb2a-393d-49e1-aab5-df4cd3fa4278",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/io/metadata.cpp"
                },
                "region": {
                  "startLine": 754,
                  "startColumn": 7,
                  "endLine": 754,
                  "endColumn": 53,
                  "charOffset": 26861,
                  "charLength": 46,
                  "snippet": {
                    "text": "memcpy(label_.data(), mem_ptr, sizeof(label_t)",
                    "rendered": {
                      "text": "memcpy(label_.data(), mem_ptr, sizeof(label_t)",
                      "markdown": "`memcpy(label_.data(), mem_ptr, sizeof(label_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/io/metadata.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26861,
                        "charLength": 46
                      },
                      "insertedContent": {
                        "text": "memcpy_s(label_.data(), <size of label_.data()>,  mem_ptr,  sizeof(label_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a9b922c7-ded7-42bf-a90a-d88fbc903a6f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/treelearner/feature_histogram.hpp"
                },
                "region": {
                  "startLine": 966,
                  "startColumn": 9,
                  "endLine": 967,
                  "endColumn": 48,
                  "charOffset": 41369,
                  "charLength": 75,
                  "snippet": {
                    "text": "memcpy(data_, memory_data,\n                (meta_->num_bin - meta_->offset)",
                    "rendered": {
                      "text": "memcpy(data_, memory_data,\n                (meta_->num_bin - meta_->offset)",
                      "markdown": "`memcpy(data_, memory_data,\n                (meta_->num_bin - meta_->offset)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/treelearner/feature_histogram.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41369,
                        "charLength": 75
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data_, <size of data_>,  memory_data, \n                (meta_->num_bin - meta_->offset)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8d2cc877-9738-420f-a4d6-eef9fd740ee8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/treelearner/feature_histogram.hpp"
                },
                "region": {
                  "startLine": 961,
                  "startColumn": 9,
                  "endLine": 962,
                  "endColumn": 48,
                  "charOffset": 41216,
                  "charLength": 75,
                  "snippet": {
                    "text": "memcpy(data_, memory_data,\n                (meta_->num_bin - meta_->offset)",
                    "rendered": {
                      "text": "memcpy(data_, memory_data,\n                (meta_->num_bin - meta_->offset)",
                      "markdown": "`memcpy(data_, memory_data,\n                (meta_->num_bin - meta_->offset)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/treelearner/feature_histogram.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 41216,
                        "charLength": 75
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data_, <size of data_>,  memory_data, \n                (meta_->num_bin - meta_->offset)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e13665b0-c3df-4c48-aac6-63da2f56c41b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/io/metadata.cpp"
                },
                "region": {
                  "startLine": 760,
                  "startColumn": 9,
                  "endLine": 760,
                  "endColumn": 57,
                  "charOffset": 27132,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(weights_.data(), mem_ptr, sizeof(label_t)",
                    "rendered": {
                      "text": "memcpy(weights_.data(), mem_ptr, sizeof(label_t)",
                      "markdown": "`memcpy(weights_.data(), mem_ptr, sizeof(label_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/io/metadata.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27132,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(weights_.data(), <size of weights_.data()>,  mem_ptr,  sizeof(label_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-033740f4-f46c-46d9-b5d3-3e1b2b182d33",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/io/metadata.cpp"
                },
                "region": {
                  "startLine": 436,
                  "startColumn": 2,
                  "endLine": 436,
                  "endColumn": 61,
                  "charOffset": 15954,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(label_.data() + start_index, labels, sizeof(label_t)",
                    "rendered": {
                      "text": "memcpy(label_.data() + start_index, labels, sizeof(label_t)",
                      "markdown": "`memcpy(label_.data() + start_index, labels, sizeof(label_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/io/metadata.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15954,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(label_.data() + start_index, <size of label_.data() + start_index>,  labels,  sizeof(label_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-44a5865f-2aa9-47c5-bfb6-2c68c05e4aef",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/io/metadata.cpp"
                },
                "region": {
                  "startLine": 400,
                  "startColumn": 4,
                  "endLine": 400,
                  "endColumn": 88,
                  "charOffset": 14776,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(init_score_.data() + dest_offset, init_scores + source_offset, sizeof(double)",
                    "rendered": {
                      "text": "memcpy(init_score_.data() + dest_offset, init_scores + source_offset, sizeof(double)",
                      "markdown": "`memcpy(init_score_.data() + dest_offset, init_scores + source_offset, sizeof(double)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/io/metadata.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14776,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(init_score_.data() + dest_offset, <size of init_score_.data() + dest_offset>,  init_scores + source_offset,  sizeof(double)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-33a0181a-d858-40f7-8f1f-3efdd13627cd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/io/bin.cpp"
                },
                "region": {
                  "startLine": 558,
                  "startColumn": 11,
                  "endLine": 558,
                  "endColumn": 75,
                  "charOffset": 22444,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(bin_2_categorical_.data(), buffer, num_bin_ * sizeof(int)",
                    "rendered": {
                      "text": "memcpy(bin_2_categorical_.data(), buffer, num_bin_ * sizeof(int)",
                      "markdown": "`memcpy(bin_2_categorical_.data(), buffer, num_bin_ * sizeof(int)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/io/bin.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 22444,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(bin_2_categorical_.data(), <size of bin_2_categorical_.data()>,  buffer,  num_bin_ * sizeof(int)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-88c82f39-d74f-421d-9f1f-e375bbacb1dd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/io/bin.cpp"
                },
                "region": {
                  "startLine": 551,
                  "startColumn": 9,
                  "endLine": 551,
                  "endColumn": 63,
                  "charOffset": 22057,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(&most_freq_bin_, buffer, sizeof(most_freq_bin_)",
                    "rendered": {
                      "text": "memcpy(&most_freq_bin_, buffer, sizeof(most_freq_bin_)",
                      "markdown": "`memcpy(&most_freq_bin_, buffer, sizeof(most_freq_bin_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/io/bin.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 22057,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&most_freq_bin_, <size of &most_freq_bin_>,  buffer,  sizeof(most_freq_bin_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-97a3636f-4543-4eff-a48b-f749e0552cc6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/io/metadata.cpp"
                },
                "region": {
                  "startLine": 574,
                  "startColumn": 2,
                  "endLine": 574,
                  "endColumn": 68,
                  "charOffset": 20394,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(queries_.data() + start_index, queries, sizeof(data_size_t)",
                    "rendered": {
                      "text": "memcpy(queries_.data() + start_index, queries, sizeof(data_size_t)",
                      "markdown": "`memcpy(queries_.data() + start_index, queries, sizeof(data_size_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/io/metadata.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20394,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(queries_.data() + start_index, <size of queries_.data() + start_index>,  queries,  sizeof(data_size_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}